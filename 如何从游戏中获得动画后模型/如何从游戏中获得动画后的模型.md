---
typora-root-url: ./
---

# 前言

因为最近我买了一台拓竹A1，所以部分业余时间放在了琢磨3D打印上，当然，也切实用3D打印解决了一些日常生活中独特的问题。

之后就考虑是否可以使用3D打印机打印一些游戏中的模型，老样子还是先掏出Renderdoc：

![image-20250719013234852](/assets/image-20250719013234852-1752863180428-1.png)

翻阅到渲染所使用的Mesh可以发现，模型是在顶点着色器中完成动画的——这不是废话，举例而言以由Unity制作的《Last Epoch》，就是先用Compute Shader对Mesh进行形变，之后再开始渲染的——也就是说，手头的数据只有未形变前的原模型和投影到屏幕之后的模型：

![image-20250719013526079](/assets/image-20250719013526079-1752863180428-2.png)

所以我花了一天多的时间研究了一下，如何从类似《尘白禁区》这类UE游戏中提取形变之后的模型。效果如下：

![image-20250719012142482](/assets/image-20250719012142482-1752863180428-4.png)

# 构造思路

解决问题时，务必要确定问题的本质，以及确定手头的信息是否足够触及该本质。

问题的本质是在LocalPosition到SV_Position的过程中，定位并输出WorldPosition。

查看顶点着色器指令，并与Mesh Viewer中的进行对比：

![image-20250719014203884](/assets/image-20250719014203884-1752863180428-3.png)

![image-20250719014244915](/assets/image-20250719014244915-1752863180428-5.png)

可以发现v0对应LocalPosition，而o5对应SV_Position。

注意，这也不是废话，因为v0、v1、v2……并不严格对应Mesh Viewer中的数据结构。

调试某个顶点，从o5往前推：

```
  57: dp3 r3.x, r0.xyzx, v1.xyzx
  58: dp3 r3.y, r1.xyzx, v1.xyzx
  59: dp3 r3.z, r2.xyzx, v1.xyzx
  60: dp3 r3.w, r0.xyzx, v2.xyzx
  61: dp3 r4.x, r1.xyzx, v2.xyzx
  62: dp3 r4.y, r2.xyzx, v2.xyzx
  63: add r5.xyz, v0.xyzx, v8.xyzx
  64: mov r5.w, l(1.000000)
  65: dp4 r0.x, r0.xyzw, r5.xyzw
  66: dp4 r0.y, r1.xyzw, r5.xyzw
  67: dp4 r0.z, r2.xyzw, r5.xyzw
  68: add r0.xyz, r0.xyzx, v9.xyzx
  69: mul r1.xyz, r0.yyyy, cb3[1].xyzx
  70: mad r0.xyw, cb3[0].xyxz, r0.xxxx, r1.xyxz
  71: mad r0.xyz, cb3[2].xyzx, r0.zzzz, r0.xywx
  72: add r1.xyz, cb1[74].xyzx, cb3[3].xyzx
  73: add r0.xyz, r0.xyzx, r1.xyzx
  74: mul r1.xyzw, r0.yyyy, cb1[1].xyzw
  75: mad r1.xyzw, r0.xxxx, cb1[0].xyzw, r1.xyzw
  76: mad r1.xyzw, r0.zzzz, cb1[2].xyzw, r1.xyzw
```

到这个地方，大致可以确定，要么是Line 63，要么是Line 68对应着WorldPosition。

愕然发现Line 69处寄存器r1被完全覆盖了，导致无法逆向追索r1在Line 69之前的值。好吧，那么从SV_Position倒推的方法是没辙了。

呃，你问我怎么确定WorldPosition的位置的？就去看看UE4的顶点着色器源码，排除无关部分之后可以看到如下内容：

```
struct FToonVSToPS
{
	INVARIANT_OUTPUT float4 Position : SV_POSITION;
	FVertexFactoryInterpolantsVSToPS FactoryInterpolants;
};

void MainVS(
	FVertexFactoryInput Input,
	out FToonVSOutput Output
	)
{

	// 获取世界空间位置
	FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(Input);
	float4 WorldPos = VertexFactoryGetWorldPosition(Input, VFIntermediates);
	float4 WorldPositionExcludingWPO = WorldPos;

	// 获取MaterialParameters
	half3x3 TangentToLocal = VertexFactoryGetTangentToLocal(Input, VFIntermediates);
	FMaterialVertexParameters VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, WorldPos.xyz, TangentToLocal);

	// 计算世界空间位置
	{
		WorldPos.xyz += GetMaterialWorldPositionOffset(VertexParameters);
	}

	// 计算SV_POSITION
	{
		float4 RasterizedWorldPosition = VertexFactoryGetRasterizedWorldPosition(Input, VFIntermediates, WorldPos);
		Output.Position = INVARIANT(mul(RasterizedWorldPosition, ResolvedView.TranslatedWorldToClip));
	}
}
```

所以WorldPosition应该发生在具有【矩阵转换+加法+矩阵转换】这种特征的地方。就这么简单。

那么剩下的方法就是只能正着推，把整个WorldPosition计算走一次。

# 数据准备

```
      dcl_constantbuffer cb0[2], immediateIndexed
      dcl_constantbuffer cb1[215], immediateIndexed
      dcl_constantbuffer cb2[47], immediateIndexed
      dcl_constantbuffer cb3[5], immediateIndexed
      dcl_sampler s0, mode_default
      dcl_resource_texture3d (float,float,float,float) t0
      dcl_resource_buffer (float,float,float,float) t1
```

依照我的理解，顶点着色器里出现个Texture多半是控制形变程度的mask，可以忽略不计，把采样操作赋予个常数即可。

然后就是要准备cb和t了。

```
   0: imul null, r0.xyzw, v3.xyzw, l(3, 3, 3, 3)
   1: ld_indexable(buffer)(float,float,float,float) r1.xyzw, r0.xxxx, t1.xyzw
   2: imad r2.xyzw, v3.xxyy, l(3, 3, 3, 3), l(1, 2, 1, 2)
   3: ld_indexable(buffer)(float,float,float,float) r3.xyzw, r2.xxxx, t1.xyzw
   4: ld_indexable(buffer)(float,float,float,float) r4.xyzw, r2.yyyy, t1.xyzw
   5: ld_indexable(buffer)(float,float,float,float) r5.xyzw, r0.yyyy, t1.xyzw
   6: ld_indexable(buffer)(float,float,float,float) r6.xyzw, r2.zzzz, t1.xyzw
   7: ld_indexable(buffer)(float,float,float,float) r2.xyzw, r2.wwww, t1.xyzw
   8: mul r5.xyzw, r5.xyzw, v5.yyyy
   9: mul r6.xyzw, r6.xyzw, v5.yyyy
  10: mul r2.xyzw, r2.xyzw, v5.yyyy
  11: mad r1.xyzw, v5.xxxx, r1.xyzw, r5.xyzw
  12: mad r3.xyzw, v5.xxxx, r3.xyzw, r6.xyzw
  13: mad r2.xyzw, v5.xxxx, r4.xyzw, r2.xyzw
  14: ld_indexable(buffer)(float,float,float,float) r4.xyzw, r0.zzzz, t1.xyzw
  15: imad r5.xyzw, v3.zzww, l(3, 3, 3, 3), l(1, 2, 1, 2)
  16: ld_indexable(buffer)(float,float,float,float) r6.xyzw, r5.xxxx, t1.xyzw
  17: ld_indexable(buffer)(float,float,float,float) r7.xyzw, r5.yyyy, t1.xyzw
  18: mad r1.xyzw, v5.zzzz, r4.xyzw, r1.xyzw
  19: mad r3.xyzw, v5.zzzz, r6.xyzw, r3.xyzw
  20: mad r2.xyzw, v5.zzzz, r7.xyzw, r2.xyzw
  21: ld_indexable(buffer)(float,float,float,float) r0.xyzw, r0.wwww, t1.xyzw
  22: ld_indexable(buffer)(float,float,float,float) r4.xyzw, r5.zzzz, t1.xyzw
  23: ld_indexable(buffer)(float,float,float,float) r5.xyzw, r5.wwww, t1.xyzw
  24: mad r0.xyzw, v5.wwww, r0.xyzw, r1.xyzw
  25: mad r1.xyzw, v5.wwww, r4.xyzw, r3.xyzw
  26: mad r2.xyzw, v5.wwww, r5.xyzw, r2.xyzw
  27: ult r3.x, l(4), cb0[1].y
  28: if_nz r3.x
  29:   imul null, r3.xyzw, v4.xyzw, l(3, 3, 3, 3)
  30:   ld_indexable(buffer)(float,float,float,float) r4.xyzw, r3.xxxx, t1.xyzw
  31:   imad r5.xyzw, v4.xxyy, l(3, 3, 3, 3), l(1, 2, 1, 2)
  32:   ld_indexable(buffer)(float,float,float,float) r6.xyzw, r5.xxxx, t1.xyzw
  33:   ld_indexable(buffer)(float,float,float,float) r7.xyzw, r5.yyyy, t1.xyzw
  34:   mad r4.xyzw, v6.xxxx, r4.xyzw, r0.xyzw
  35:   mad r6.xyzw, v6.xxxx, r6.xyzw, r1.xyzw
  36:   mad r7.xyzw, v6.xxxx, r7.xyzw, r2.xyzw
  37:   ld_indexable(buffer)(float,float,float,float) r8.xyzw, r3.yyyy, t1.xyzw
  38:   ld_indexable(buffer)(float,float,float,float) r9.xyzw, r5.zzzz, t1.xyzw
  39:   ld_indexable(buffer)(float,float,float,float) r5.xyzw, r5.wwww, t1.xyzw
  40:   mad r4.xyzw, v6.yyyy, r8.xyzw, r4.xyzw
```

这一直用v3去t1里索引东西，v3、v4是这玩意儿：

![image-20250719020354182](/assets/image-20250719020354182-1752863180428-9.png)

所以一眼可以肯定这段可以写成：

```
获取4个骨骼索引
用骨骼索引检索蒙皮权重
if 影响蒙皮的骨骼 == 8:
	获取后面4个骨骼索引
	用骨骼索引检索蒙皮权重
```

OK，那就是准备好t和cb就可以了。

注意Buffer的导出方式，是这样导出：

![image-20250719020835968](/assets/image-20250719020835968-1752863180428-6.png)

这也不是废话，因为走左上角导出是导出未经解读的元数据；右键导出是导出解读为float之后的数据。

# 具体实现

有了思路有了数据，剩下就是实现。

1. 先将cb、t、LocalPosition反序列化
2. 对于每个顶点，按照指令的推进逐步用python实现
3. 最后到Line 63/68行停止并导出当前寄存器内容
4. 重新组织为csv，并用Houdini进行读入组合

为了写起来方便，我用的是pyglm库，可以直接写v0.xyz、v0.zzzz这种写法，看起来更加舒服。

```
import os
import glm
from glm import vec4, vec3, vec2, ivec4, dot

vertex_inputs = []
buffers = {}
vertex_count = 0

def cb(cbidx : int, offset : int):
    name = "cb" + str(cbidx) + "_" + str(offset)
    if name in buffers:
        vector = buffers[name]
        return vec4(vector.x, vector.y, vector.z, vector.w)
    else:
        raise ValueError(f"Buffer {name} not found.")
    
def t(tidx : int, offset : int):
    name = "t" + str(tidx) + "_" + str(offset)
    if name in buffers:
        vector = buffers[name]
        return vec4(vector.x, vector.y, vector.z, vector.w)
    else:
        raise ValueError(f"Buffer {name} not found.")

def init_vertex_input(csv_file_path : str):
    global vertex_inputs, vertex_count
    vertex_count = 0
    vertex_inputs.clear()
    with open(csv_file_path, 'r') as csv_file:
        lines = csv_file.readlines()
    lines0 = lines[0].strip().split(',')
    lines0 = [x.strip().replace('ATTRIBUTE', 'v') for x in lines0]
    datalines = lines[1:]
    vertex_count = len(datalines)
    for dataline in datalines:
        datas = dataline.strip().split(',')
        datas = [float(x.strip()) for x in datas]
        vertex_inputs.append(datas)
    # print(vertex_count, "vertices initialized.")

def init_resources(filename : str):
    global buffers
    buffers.clear()
    # 目前我发现其实压根没用上cb
    # cbuffer_dir = "cb/" + filename
    # for file in os.listdir(cbuffer_dir):
    #     if file.endswith('.csv'):
    #         with open(os.path.join(cbuffer_dir, file), 'r') as csv_file:
    #             lines = csv_file.readlines()[1:]
    #             for idx, line in enumerate(lines):
    #                 data = line.split('"')[1]
    #                 data = data.split(',')
    #                 data = [float(x.strip()) for x in data]
    #                 buffer_name = file[:-4] + "_" + str(idx)
    #                 buffers[buffer_name] = glm.vec4(*data)
    #                 # print(f"Buffer {buffer_name} initialized with data: {data}")
    tbuffer_dir = "t/" + filename
    for file in os.listdir(tbuffer_dir):
        if file.endswith('.csv'):
            with open(os.path.join(tbuffer_dir, file), 'r') as csv_file:
                lines = csv_file.readlines()[1:]
                for idx, line in enumerate(lines):
                    data = line.split(',')[1:]
                    data = [float(x.strip()) for x in data]
                    buffer_name = file[:-4] + "_" + str(idx)
                    buffers[buffer_name] = glm.vec4(*data)
                    # print(f"Buffer {buffer_name} initialized with data: {data}")

def convert_csv(filename : str):
    csv_file_path = "csv/" + filename + ".csv"
    init_vertex_input(csv_file_path)
    init_resources(filename)
    
    csv_content = "VTX,\tIDX,\tPosition.x,\tPosition.y,\tPosition.z\n"
    for i in range(vertex_count):
        position = get_world_position(i)
        VTX = vertex_inputs[i][0]
        IDX = vertex_inputs[i][1]
        csv_content += f"{VTX},\t{IDX},\t{position.x},\t{position.y},\t{position.z}\n"
    with open(filename + ".csv", "w") as output_file:
        output_file.write(csv_content)

def get_world_position(vid : int) -> vec3:
    global vertex_inputs, buffers
    def _v0() -> vec4:
        data = vertex_inputs[vid][2:][0:3]
        return vec4(data[0], data[1], data[2], 1.0)
    def _v1() -> vec3:
        data = vertex_inputs[vid][2:][3:7]
        return vec3(data[0], data[1], data[2])
    def _v2() -> vec4:
        data = vertex_inputs[vid][2:][7:11]
        return vec4(data[0], data[1], data[2], data[3])
    def _v3() -> ivec4:
        data = vertex_inputs[vid][2:][17:21]
        return ivec4(int(data[0]), int(data[1]), int(data[2]), int(data[3]))
    def _v4() -> ivec4:
        data = vertex_inputs[vid][2:][21:25]
        return ivec4(int(data[0]), int(data[1]), int(data[2]), int(data[3]))
    def _v5() -> vec4:
        data = vertex_inputs[vid][2:][25:29]
        return vec4(data[0], data[1], data[2], data[3])
    def _v6() -> vec4:
        data = vertex_inputs[vid][2:][29:33]
        return vec4(data[0], data[1], data[2], data[3])
    def _v7() -> vec2:
        data = vertex_inputs[vid][2:][11:13]
        return vec2(data[0], data[1])
    def _v8() -> vec3:
        data = vertex_inputs[vid][2:][36:39]
        return vec3(data[0], data[1], data[2])
    def _v9() -> vec3:
        data = vertex_inputs[vid][2:][33:36]
        return vec3(data[0], data[1], data[2])
    def _v10() -> vec4:
        data = vertex_inputs[vid][2:][13:17]
        return vec4(data[0], data[1], data[2], data[3])

    v0 = _v0()
    v1 = _v1()
    v2 = _v2()
    v3 = _v3()
    v4 = _v4()
    v5 = _v5()
    v6 = _v6()
    v7 = _v7()
    v8 = _v8()
    v9 = _v9()
    v10 = _v10()
    # 开始逆向
#    0: imul null, r0.xyzw, v3.xyzw, l(3, 3, 3, 3)
    r0 = v3 * ivec4(3, 3, 3, 3)
#    1: ld_indexable(buffer)(float,float,float,float) r1.xyzw, r0.xxxx, t1.xyzw
    r1 = t(1, int(r0.x))
#    2: imad r2.xyzw, v3.xxyy, l(3, 3, 3, 3), l(1, 2, 1, 2)
    r2 = v3.xxyy * ivec4(3, 3, 3, 3) + ivec4(1, 2, 1, 2)
#    3: ld_indexable(buffer)(float,float,float,float) r3.xyzw, r2.xxxx, t1.xyzw
    r3 = t(1, int(r2.x))
#    4: ld_indexable(buffer)(float,float,float,float) r4.xyzw, r2.yyyy, t1.xyzw
    r4 = t(1, int(r2.y))
#    5: ld_indexable(buffer)(float,float,float,float) r5.xyzw, r0.yyyy, t1.xyzw
    r5 = t(1, int(r0.y))
#    6: ld_indexable(buffer)(float,float,float,float) r6.xyzw, r2.zzzz, t1.xyzw
    r6 = t(1, int(r2.z))
#    7: ld_indexable(buffer)(float,float,float,float) r2.xyzw, r2.wwww, t1.xyzw
    r2 = t(1, int(r2.w))
#    8: mul r5.xyzw, r5.xyzw, v5.yyyy
    r5 = r5 * v5.yyyy
#    9: mul r6.xyzw, r6.xyzw, v5.yyyy+
    r6 = r6 * v5.yyyy
#   10: mul r2.xyzw, r2.xyzw, v5.yyyy
    r2 = r2 * v5.yyyy
#   11: mad r1.xyzw, v5.xxxx, r1.xyzw, r5.xyzw
    r1 = v5.xxxx * r1 + r5
#   12: mad r3.xyzw, v5.xxxx, r3.xyzw, r6.xyzw
    r3 = v5.xxxx * r3 + r6
#   13: mad r2.xyzw, v5.xxxx, r4.xyzw, r2.xyzw
    r2 = v5.xxxx * r4 + r2
#   14: ld_indexable(buffer)(float,float,float,float) r4.xyzw, r0.zzzz, t1.xyzw
    r4 = t(1, int(r0.z))
#   15: imad r5.xyzw, v3.zzww, l(3, 3, 3, 3), l(1, 2, 1, 2)
    r5 = v3.zzww * ivec4(3, 3, 3, 3) + ivec4(1, 2, 1, 2)
#   16: ld_indexable(buffer)(float,float,float,float) r6.xyzw, r5.xxxx, t1.xyzw
    r6 = t(1, int(r5.x))
#   17: ld_indexable(buffer)(float,float,float,float) r7.xyzw, r5.yyyy, t1.xyzw
    r7 = t(1, int(r5.y))
#   18: mad r1.xyzw, v5.zzzz, r4.xyzw, r1.xyzw
    r1 = v5.zzzz * r4 + r1
#   19: mad r3.xyzw, v5.zzzz, r6.xyzw, r3.xyzw
    r3 = v5.zzzz * r6 + r3
#   20: mad r2.xyzw, v5.zzzz, r7.xyzw, r2.xyzw
    r2 = v5.zzzz * r7 + r2
#   21: ld_indexable(buffer)(float,float,float,float) r0.xyzw, r0.wwww, t1.xyzw
    r0 = t(1, int(r0.w))
#   22: ld_indexable(buffer)(float,float,float,float) r4.xyzw, r5.zzzz, t1.xyzw
    r4 = t(1, int(r5.z))
#   23: ld_indexable(buffer)(float,float,float,float) r5.xyzw, r5.wwww, t1.xyzw
    r5 = t(1, int(r5.w))
#   24: mad r0.xyzw, v5.wwww, r0.xyzw, r1.xyzw
    r0 = v5.wwww * r0 + r1
#   25: mad r1.xyzw, v5.wwww, r4.xyzw, r3.xyzw
    r1 = v5.wwww * r4 + r3
#   26: mad r2.xyzw, v5.wwww, r5.xyzw, r2.xyzw
    r2 = v5.wwww * r5 + r2
#   27: ult r3.x, l(4), cb0[1].y
    r3.x = 1 if 4 < 8 else 0 # cb0[1].y is 8 maybe
#   28: if_nz r3.x
    if r3.x != 0:
#   29:   imul null, r3.xyzw, v4.xyzw, l(3, 3, 3, 3)
        r3 = v4 * ivec4(3, 3, 3, 3)
#   30:   ld_indexable(buffer)(float,float,float,float) r4.xyzw, r3.xxxx, t1.xyzw
        r4 = t(1, int(r3.x))
#   31:   imad r5.xyzw, v4.xxyy, l(3, 3, 3, 3), l(1, 2, 1, 2)
        r5 = v4.xxyy * ivec4(3, 3, 3, 3) + ivec4(1, 2, 1, 2)
#   32:   ld_indexable(buffer)(float,float,float,float) r6.xyzw, r5.xxxx, t1.xyzw
        r6 = t(1, int(r5.x))
#   33:   ld_indexable(buffer)(float,float,float,float) r7.xyzw, r5.yyyy, t1.xyzw
        r7 = t(1, int(r5.y))
#   34:   mad r4.xyzw, v6.xxxx, r4.xyzw, r0.xyzw
        r4 = v6.xxxx * r4 + r0
#   35:   mad r6.xyzw, v6.xxxx, r6.xyzw, r1.xyzw
        r6 = v6.xxxx * r6 + r1
#   36:   mad r7.xyzw, v6.xxxx, r7.xyzw, r2.xyzw
        r7 = v6.xxxx * r7 + r2
#   37:   ld_indexable(buffer)(float,float,float,float) r8.xyzw, r3.yyyy, t1.xyzw
        r8 = t(1, int(r3.y))
#   38:   ld_indexable(buffer)(float,float,float,float) r9.xyzw, r5.zzzz, t1.xyzw
        r9 = t(1, int(r5.z))
#   39:   ld_indexable(buffer)(float,float,float,float) r5.xyzw, r5.wwww, t1.xyzw
        r5 = t(1, int(r5.w))
#   40:   mad r4.xyzw, v6.yyyy, r8.xyzw, r4.xyzw
        r4 = v6.yyyy * r8 + r4
#   41:   mad r6.xyzw, v6.yyyy, r9.xyzw, r6.xyzw
        r6 = v6.yyyy * r9 + r6
#   42:   mad r5.xyzw, v6.yyyy, r5.xyzw, r7.xyzw
        r5 = v6.yyyy * r5 + r7
#   43:   ld_indexable(buffer)(float,float,float,float) r7.xyzw, r3.zzzz, t1.xyzw
        r7 = t(1, int(r3.z))
#   44:   imad r8.xyzw, v4.zzww, l(3, 3, 3, 3), l(1, 2, 1, 2)
        r8 = v4.zzww * ivec4(3, 3, 3, 3) + ivec4(1, 2, 1, 2)
#   45:   ld_indexable(buffer)(float,float,float,float) r9.xyzw, r8.xxxx, t1.xyzw
        r9 = t(1, int(r8.x))
#   46:   ld_indexable(buffer)(float,float,float,float) r10.xyzw, r8.yyyy, t1.xyzw
        r10 = t(1, int(r8.y))
#   47:   mad r4.xyzw, v6.zzzz, r7.xyzw, r4.xyzw
        r4 = v6.zzzz * r7 + r4
#   48:   mad r6.xyzw, v6.zzzz, r9.xyzw, r6.xyzw
        r6 = v6.zzzz * r9 + r6
#   49:   mad r5.xyzw, v6.zzzz, r10.xyzw, r5.xyzw
        r5 = v6.zzzz * r10 + r5
#   50:   ld_indexable(buffer)(float,float,float,float) r3.xyzw, r3.wwww, t1.xyzw
        r3 = t(1, int(r3.w))
#   51:   ld_indexable(buffer)(float,float,float,float) r7.xyzw, r8.zzzz, t1.xyzw
        r7 = t(1, int(r8.z))
#   52:   ld_indexable(buffer)(float,float,float,float) r8.xyzw, r8.wwww, t1.xyzw
        r8 = t(1, int(r8.w))
#   53:   mad r0.xyzw, v6.wwww, r3.xyzw, r4.xyzw
        r0 = v6.wwww * r3 + r4
#   54:   mad r1.xyzw, v6.wwww, r7.xyzw, r6.xyzw
        r1 = v6.wwww * r7 + r6
#   55:   mad r2.xyzw, v6.wwww, r8.xyzw, r5.xyzw
        r2 = v6.wwww * r8 + r5
#   56: endif
#   57: dp3 r3.x, r0.xyzx, v1.xyzx
    r3.x = dot(r0.xyz, v1.xyz)
#   58: dp3 r3.y, r1.xyzx, v1.xyzx
    r3.y = dot(r1.xyz, v1.xyz)
#   59: dp3 r3.z, r2.xyzx, v1.xyzx
    r3.z = dot(r2.xyz, v1.xyz)
#   60: dp3 r3.w, r0.xyzx, v2.xyzx
    r3.w = dot(r0.xyz, v2.xyz)
#   61: dp3 r4.x, r1.xyzx, v2.xyzx
    r4.x = dot(r1.xyz, v2.xyz)
#   62: dp3 r4.y, r2.xyzx, v2.xyzx
    r4.y = dot(r2.xyz, v2.xyz)
#   63: add r5.xyz, v0.xyzx, v8.xyzx
    r5.xyz = v0.xyz + v8.xyz
#   64: mov r5.w, l(1.000000)
    r5.w = 1.0
#   65: dp4 r0.x, r0.xyzw, r5.xyzw
    r0.x = dot(r0.xyzw, r5.xyzw)
#   66: dp4 r0.y, r1.xyzw, r5.xyzw
    r0.y = dot(r1.xyzw, r5.xyzw)
#   67: dp4 r0.z, r2.xyzw, r5.xyzw
    r0.z = dot(r2.xyzw, r5.xyzw)
#   68: add r0.xyz, r0.xyzx, v9.xyzx
    r0.xyz = r0.xyz + v9.xyz
    return r0.xyz

def get_texcoord(vid : int) -> vec2:
    global vertex_inputs
    data = vertex_inputs[vid][2:][11:13]
    return vec2(data[0], data[1])

for file in os.listdir("csv"):
    if file.endswith('.csv'):
        filename = file[:-4]
        print(f"Converting {filename}...")
        convert_csv(filename)
        print(f"{filename} converted successfully.")

# vex脚本：
# int count = npoints(0);
# for (int i = 0; i < count / 3; i++)
# {
#     int p0 = i * 3;
#     int p1 = i * 3 + 1;
#     int p2 = i * 3 + 2;
#     addprim(0, "poly", p0, p2, p1);
# }
```

最后确定是Line 68对应WorldPosition。

# 瑕疵

夜深了就长话短说。

![image-20250719021438454](/assets/image-20250719021438454-1752863180428-7.png)

有神秘的穿插，具体原因不知，因为我没时间在几万个顶点中去找真正发生计算失误的点。

不同部位很可能使用了不同的顶点着色器算法，例如，在这里，头部、腿部模型若用衣物模型顶点着色器指令推进，则表现完全不一样，所以还是要每个部件单独处理：

![image-20250719021814708](/assets/image-20250719021814708-1752863180428-8.png)

当然，很麻烦就是了。所以我这里是简单bridge一下然后fuse，爱咋地咋地。

最后就是3D打印领域的事情了，整了半天这模型也不能直接上3D打印机，有大量非流形区域，而且眼部模型嘛……不是眼球，所以这里打印的时候会直接掏空：

![image-20250719022043134](/assets/image-20250719022043134-1752863180428-10.png)

![X](/assets/12ZB0YBXN0{2[S7JK2UZA[X.png)

总之还是没打印出来，忙活一天权作一乐。

那么大概就是这样。