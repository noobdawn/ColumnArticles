---
typora-root-url: ./
---

# 前言

周五的时候看到了这个个人独游创意[【来点纯粹的光影玩法】]( https://www.bilibili.com/video/BV1oUuhzpEHy)，和程序讨论了一下，发现还是蛮有意思的。

我自己是寻思出了几个思路，捡了个最简单的思路，查点API，然后稍微验证下，发现是可行的。

然后周六大概做了下，效果如下：

<video src="assets\ShadowProject - SampleScene - Windows, Mac, Linux - Unity 6.1 (6000.1.12f1) _DX12_ 2025-07-20 15-52-14.mp4"></video>

乐，果然我没有审美能力。

虽然已经转向UE了，不过要写Gameplay的话，我还是习惯用Unity，咳咳……团结引擎，看我口型（

工程地址放在这里叻，请忽略我胡乱编写的名字和资产组织方式嘻嘻：

https://github.com/noobdawn/Unity_WalkOnShadow

# 思路

这个简化版的思路就很简单，其主体用的是Unity的2D碰撞系统，然后逻辑设计设这样的：角色运动发生在某个平面（本例中为 z = 4 的平面）内，将模型分拆为若干简单凸多面体，然后映射到该平面内并生成PolygonCollider2D。

完事。下图你可以看到由凸多面体映射到平面上形成的凸多边形的形状，与聚光灯的投影很好地吻合在一起。

![Unity_j4TRBJWRAJ](/assets/Unity_j4TRBJWRAJ-1753001631925-2.gif)

然后分拆的简单凸多面体是这样的：

![image-20250720160944687](/assets/image-20250720160944687-1753001631934-3.png)

# 核心代码

核心代码就干一件事：

1. 获得mesh
2. 把mesh中每个顶点映射到点光源的投影空间
3. 把顶点过一次凸包检测，得到凸多边形
4. 扔进polygon collider 2d组件

完事：

```c#
    private void FixedUpdate()
    {
        colliderMesh = Instantiate(meshFilter.sharedMesh);
        // 获取投影矩阵
        Matrix4x4 viewMatrix = spotlight.transform.worldToLocalMatrix;
        Matrix4x4 projectionMatrix = Matrix4x4.Perspective(
            spotlight.spotAngle,
            1.0f,
            spotlight.shadowNearPlane,
            spotlight.range
        );
        Matrix4x4 gpuProjMatrix = GL.GetGPUProjectionMatrix(projectionMatrix, true);
        Matrix4x4 worldMatrix = spotlight.transform.localToWorldMatrix;
        Matrix4x4 lightReprojectMatrix = gpuProjMatrix * viewMatrix;
        // 对colliderMesh的每个顶点做重映射
        Vector3[] vertices = colliderMesh.vertices;
        Vector2[] vertice2ds = new Vector2[vertices.Length];
        for (int i = 0; i < vertices.Length; i++)
        {
            Vector3 vertex = vertices[i];
            // 将顶点从局部空间转换到世界空间
            Vector3 worldVertex = child.TransformPoint(vertex);
            // 将世界空间顶点转换到光源的投影空间
            Vector4 projectedVertex = lightReprojectMatrix * new Vector4(worldVertex.x, worldVertex.y, worldVertex.z, 1.0f);
            // 将投影坐标归一化
            projectedVertex /= projectedVertex.w;
            projectedVertex.x *= scale;
            projectedVertex.y *= scale;
            projectedVertex.z = 0;
            projectedVertex.x *= -1;
            // 不一定要搞回world，是你自身控制灯光的方式而定
            worldVertex = worldMatrix * projectedVertex;
            vertice2ds[i] = new Vector2(worldVertex.x, worldVertex.y);
        }
        Vector2[] convexHull = ConvexHull2D.GetConvexPolygon(vertice2ds);
        for (int i = 0; i < convexHull.Length; i++)
        {
            // 将2D点转换为3D点
            Vector3 WorldPositions = new Vector3(convexHull[i].x, convexHull[i].y, 0);
            Vector3 LocalPosition = transform.InverseTransformPoint(WorldPositions);
            convexHull[i] = LocalPosition;
        }
        polygonCollider.SetPath(0, convexHull);
    }
```

# 其他构想

纯CPU组织collider还是太笨重了，我另外还构思了另一种方案，相对更复杂，但效果更完美：

1. 无论是单独绘制也好，还是在GBuffer里用CustomData标记也好，把【角色运动所在的表面深度】单独渲染到一张RT上；
2. 判断是否在影子中，此事在ShadowMap中已有记载；
3. 然后在Compute Shader中，先用算子找到边缘，然后深度转世界坐标；
4. 在下一帧时将边缘的世界坐标读出，然后生成Collider

总之为了流畅性，最好还是扔掉默认的物理系统自己写一个比较好。